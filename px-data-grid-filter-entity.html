<link rel="import" href="../polymer/polymer-element.html">
<link rel="import" href="../px-datetime-picker/px-datetime-picker.html">
<link rel="import" href="../px-slider/px-slider.html">
<link rel="import" href="../px-rangepicker/px-rangepicker.html">
<link rel="import" href="css/px-data-grid-filter-entity-styles.html">

<dom-module id="px-data-grid-filter-entity">
  <template>
    <style include="px-data-grid-filter-entity-styles"></style>

    <div class="labeled-text">
      <label for="column-dropdown" hidden="[[compactMode]]">
        [[localize('Attribute')]]
      </label>
      <px-dropdown
        id="column-dropdown"
        allow-outside-scroll
        items="[[_mappedColumns]]"
        disable-clear
        selected="{{entity.columnId}}"
        hoist>
      </px-dropdown>
    </div>

    <template is="dom-if" if="{{_columnTypeIsString(entity.columnId)}}" restamp>
      <div class="labeled-text">
        <label for="condition-dropdown" hidden="[[compactMode]]">
          [[localize('Condition')]]
        </label>
        <px-dropdown
          id="condition-dropdown"
          allow-outside-scroll
          items="[[_resolveRegexPatterns(stringComparators, _regexPatterns)]]"
          disable-clear
          selected="{{entity.pattern}}"
          hoist>
        </px-dropdown>
      </div>

      <div class="labeled-text">
        <label for="value-input" hidden="[[compactMode]]">
          [[localize('Value')]]
        </label>
        <input id="value-input" type="text" class="text-input" value="{{entity.query::input}}">
      </div>
    </template>

    <template is="dom-if" if="{{_columnTypeIsDateAndRangesNotAvailable(entity.columnId, _dateRanges)}}" restamp>
        <div class="labeled-text" extended>
          <px-rangepicker
            id="date-rangepicker"
            hide-time="[[_hideTime]]"
            hide-presets
            date-format="[[_datePickerDateFormat]]"
            time-format="[[_datePickerTimeFormat]]"
            time-zone="[[_displayTimezone]]"
            show-time-zone="[[_showTimeZone]]"
            show-field-titles
            from-moment="{{_dateFrom}}"
            to-moment="{{_dateTo}}"
            full-width
            hoist>
          </px-rangepicker>
        </div>
      </template>

    <template is="dom-if" if="{{_columnTypeIsDateAndRangesAvailable(entity.columnId, _dateRanges)}}" restamp>
      <div class="labeled-text">
        <label for="date-range-dropdown" hidden="[[compactMode]]">
          [[localize('Time range')]]
        </label>
        <px-dropdown
          id="date-range-dropdown"
          items="[[_dateRanges]]"
          disable-clear
          selected="{{entity.selectedDateRangeName}}"
          hoist>
        </px-dropdown>
      </div>

      <!-- Disabled in px-data-grid/pull/696 -->
      <!-- <template is="dom-if" if="{{_showRangePicker(entity, entity.selectedDateRangeName, entity.columnId)}}">
        <div class="labeled-text own-row" extended>
          <px-rangepicker
            id="date-rangepicker"
            hide-time="[[_hideTime]]"
            hide-presets
            date-format="[[_displayDateFormat]]"
            time-format="[[_displayTimeFormat]]"
            time-zone="[[_displayTimezone]]"
            show-time-zone="abbreviatedText"
            show-field-titles
            from-moment="{{_dateFrom}}"
            to-moment="{{_dateTo}}">
          </px-rangepicker>
        </div>
      </template> -->
    </template>

    <template is="dom-if" if="{{_columnTypeIsNumber(entity.columnId)}}" restamp>
      <template is="dom-if" if="{{!_showSlider(_minNumberBound, _maxNumberBound, columns.*)}}" restamp>
        <div class="labeled-text">
          <label for="range-input" hidden="[[compactMode]]">
            [[localize('Condition')]]
          </label>
          <px-dropdown
            id="number-condition-dropdown"
            allow-outside-scroll
            items="[[_resolveNumberConditions(numberComparators, _numberConditions)]]"
            disable-clear
            selected="{{entity.condition}}"
            hoist>
          </px-dropdown>
        </div>

        <div class="labeled-text">
          <label for="number-value-input" hidden="[[compactMode]]">
            [[localize('Value')]]
          </label>
          <input id="number-value-input" type="text" class="text-input" value="{{entity.value::input}}">
        </div>
      </template>

      <template is="dom-if" if="{{_showSlider(_minNumberBound, _maxNumberBound, columns.*)}}" restamp>
        <div class="labeled-text" extended>
          <label for="range-input" hidden="[[compactMode]]">
            [[localize('Range')]]
          </label>
          <px-slider
            id="range-input"
            min="[[_minNumberBound]]"
            max="[[_maxNumberBound]]"
            value="{{entity.leftBound}}"
            end-value="{{entity.rightBound}}"
            step="1"
            is-range>
          </px-slider>
        </div>
      </template>
    </template>
  </template>
  <script>
    {
      /**
       * @memberof Predix
       * @extends Polymer.Element
       */
      class DataGridFilterEntityElement extends Polymer.Element {
        static get is() {
          return 'px-data-grid-filter-entity';
        }

        static get properties() {
          return {
            columns: Array,

            tableData: Array,

            entity: {
              type: Object
            },

            compactMode: {
              type: Boolean,
              value: false
            },

            stringComparators: {
              type: Array
            },

            numberComparators: {
              type: Array
            },

            useTimezones: {
              type: Boolean
            },

            _showTimeZone: {
              type: String,
              value: 'none'
            },

            _mappedColumns: Array,

            _regexPatterns: {
              type: Array,
              value: [
                {
                  key: 'equals',
                  val: 'Equals'
                },
                {
                  key: 'contains',
                  val: 'Contains'
                },
                {
                  key: 'starts_with',
                  val: 'Starts with'
                },
                {
                  key: 'ends_with',
                  val: 'Ends with'
                },
                {
                  key: 'wildcard',
                  val: 'Wildcard'
                }
              ]
            },

            _numberConditions: {
              type: Array,
              value: [
                {
                  key: 'equals',
                  val: 'Equals'
                },
                {
                  key: 'not_equal',
                  val: 'Not equal'
                },
                {
                  key: 'equal_or_greater_than',
                  val: 'Equal or greater than'
                },
                {
                  key: 'equal_or_less_than',
                  val: 'Equal or less than'
                },
                {
                  key: 'greater_than',
                  val: 'Greater than'
                },
                {
                  key: 'less_than',
                  val: 'Less than'
                }
              ]
            },

            _minNumberBound: Number,

            _maxNumberBound: Number,

            _dateRanges: {
              type: Array,
              value: []
            },

            _hideTime: {
              type: Boolean,
              value: true
            },

            _dateFrom: {
              type: Object
            },

            _dateTo: {
              type: Object
            },

            _sourceDateFormat: {
              type: String
            },

            _sourceTimezone: {
              type: String
            },

            _displayDateFormat: {
              type: String
            },

            _displayTimezone: {
              type: String
            },

            _datePickerDateFormat: {
              type: String
            },

            _datePickerTimeFormat: {
              type: String
            },

            localize: Function
          };
        }

        static get observers() {
          return [
            '_setMappedColumns(columns, columns.*)',
            '_filterActiveObservable(entity, entity.*)',
            '_momentDatesObserver(_dateFrom, _dateTo, _dateFrom.*, _dateTo.*)',
            // '_entityDatesObserver(entity, entity.dateFrom, entity.dateTo)',
            '_localizeChanged(localize)',
            '_useTimezonesChanged(useTimezones)',
            '_entityObserver(entity, entity.*)',
            '_columnNumberBoundsObserver(entity, entity.columnId, columns.*)',
            '_setDateRanges(entity, columns, entity.columnId, columns.*)',
            '_selectedDateRangeObserver(entity, entity.selectedDateRangeName, entity.columnId)'
          ];
        }

        _localizeChanged(localize) {
          if (!localize) {
            return;
          }

          this._regexPatterns.forEach((pattern, index) => {
            this.set(`_regexPatterns.${index}.val`, localize(pattern.val));
          });

          this._numberConditions.forEach((condition, index) => {
            this.set(`_numberConditions.${index}.val`, localize(condition.val));
          });
        }

        _useTimezonesChanged(useTimezones) {
          this._showTimeZone = useTimezones ? 'dropdown' : 'none';
        }

        _setDateRanges(entity, columns) {
          const selectedColumn = this._getColumnById(entity.columnId);
          if (!selectedColumn || selectedColumn.type !== 'date') {
            return;
          }

          const dateRanges = [];

          if (selectedColumn.dateRanges) {
            selectedColumn.dateRanges.forEach((dateRange) => {
              dateRanges.push({
                key: dateRange.name,
                val: this.localize(dateRange.name)
              });
            });
          }

          if (dateRanges.length > 0) {
            this.set('_dateRanges', dateRanges);
            if (!entity.selectedDateRangeName) {
              this.set('entity.selectedDateRangeName', dateRanges[0].key);
            }
          } else {
            this.set('_dateRanges', undefined);
            this.set('entity.selectedDateRangeName', undefined);
          }

          if (selectedColumn.filterByTime) {
            this.set('_hideTime', false);
          } else {
            this.set('_hideTime', true);
          }

          // source data format
          if (selectedColumn.dateFormat) {
            this.set('_sourceDateFormat', selectedColumn.dateFormat.format || 'YYYY/MM/DDD HH:mm:ss');
            this.set('_sourceTimezone', selectedColumn.dateFormat.timezone || 'UTC');
          }

          // display data format
          if (selectedColumn.rendererConfig) {
            this.set('_displayDateFormat', selectedColumn.rendererConfig.datePickerDateFormat || 'YYYY/MM/DD');
            this.set('_displayTimeFormat', selectedColumn.rendererConfig.datePickerTimeFormat || 'HH:mm');
            this.set('_displayTimezone', selectedColumn.rendererConfig.timezone || 'UTC');
            this.set('_datePickerDateFormat', selectedColumn.rendererConfig.datePickerDateFormat || 'YYYY/MM/DD');
            this.set('_datePickerTimeFormat', selectedColumn.rendererConfig.datePickerTimeFormat || 'HH:mm');
          }
        }

        _getRangeByName(columnId, name) {
          const selectedColumn = this._getColumnById(columnId);
          if (selectedColumn.dateRanges) {
            return selectedColumn.dateRanges.filter((dateRange) => dateRange.name === name)[0];
          }
        }

        _selectedDateRangeObserver(entity) {
          if (!entity.selectedDateRangeName) {
            return;
          }

          const rangeObject = this._getRangeByName(this.entity.columnId, entity.selectedDateRangeName);

          if (rangeObject && (typeof rangeObject.range === 'object' || typeof rangeObject.getRange == 'function')) {
            const dateRange = rangeObject.range ? rangeObject.range : rangeObject.getRange();

            this.set('entity.dateFrom', dateRange.dateFrom);
            this.set('entity.dateTo', dateRange.dateTo);
          } else {
            this.set('entity.dateFrom', undefined);
            this.set('entity.dateTo', undefined);
          }
        }

        _columnNumberBoundsObserver(entity) {
          const column = this._getColumnById(entity.columnId);
          if (!this._columnTypeIsNumber(entity.columnId)) {
            return;
          }

          if (this.entity.leftBound === undefined) {
            this.set('entity.leftBound', column.minBound);
          }
          if (this.entity.rightBound === undefined) {
            this.set('entity.rightBound', column.maxBound);
          }

          this._minNumberBound = column.minBound;
          this._maxNumberBound = column.maxBound;
        }

        _entityObserver(entity) {
          if (!entity.columnId) {
            this.set('entity.columnId', '-any-');
          }

          if (this._columnTypeIsString(this.entity.columnId) && this.entity.pattern === undefined) {
            this.set('entity.pattern', this._resolveRegexPatterns(this.stringComparators, this._regexPatterns)[0].key);
          } else if (this._columnTypeIsNumber(this.entity.columnId) && this.entity.condition === undefined) {
            this.set('entity.condition', this._resolveNumberConditions(this.numberComparators, this._numberConditions)[0].key);
          }
        }

        _resolveColumnName(column) {
          return column.header ? column.header : (column.name ? column.name : column.path);
        }

        _setMappedColumns(columns, columnsSplices) {
          if (!columns && !columnsSplices) {
            return;
          }

          const optionList = [];

          optionList.push({
            key: '-any-',
            val: 'Any column'
          });

          columns.forEach((col) => {
            optionList.push({
              key: col.id,
              val: this._resolveColumnName(col)
            });
          });

          this.set('_mappedColumns', optionList);
        }

        _columnTypeIsString(columnId) {
          const column = this._getColumnById(columnId);

          return column && ['date', 'number'].indexOf(column.type) === -1;
        }

        _columnTypeIsDate(columnId) {
          const column = this._getColumnById(columnId);

          return column && column.type === 'date';
        }

        _columnTypeIsDateAndRangesAvailable(columnId, ranges) {
          if (this._columnTypeIsDate(columnId)) {
            return ranges !== undefined && ranges.length > 0;
          }
          return false;
        }

        _columnTypeIsDateAndRangesNotAvailable(columnId, ranges) {
          if (this._columnTypeIsDate(columnId)) {
            return ranges === undefined || ranges.length < 1;
          }
          return false;
        }

        _columnTypeIsNumber(columnId) {
          const column = this._getColumnById(columnId);

          return column && column.type === 'number';
        }

        _getColumnById(columnId) {
          if (!this.columns) {
            return;
          }

          if (columnId === '-any-') {
            return {
              id: '-any-',
              type: 'string'
            };
          }

          return this.columns.filter((column) => column.id === columnId)[0];
        }

        _filterActiveObservable(entity) {
          if (entity.columnId !== undefined) {
            if (this._columnTypeIsString(entity.columnId)) {
              this.set('entity.active', entity.pattern !== undefined && !!entity.query);
            } else if (this._columnTypeIsDate(entity.columnId)) {
              this.set('entity.active', entity.dateFrom !== undefined || entity.dateTo !== undefined);
            } else if (this._columnTypeIsNumber(entity.columnId)) {
              this.set('entity.active',
                (entity.leftBound !== undefined || entity.rightBound !== undefined) ||
                (entity.condition !== undefined && entity.value !== undefined)
              );
            }
          }
        }

        _momentDatesObserver(dateFrom, dateTo) {
          if (dateFrom && window.Px.moment(this.entity.dateFrom).format() !== dateFrom.format()) {
            this.set('entity.dateFrom', dateFrom.tz(this._sourceTimezone).format(this._sourceDateFormat));
          }
          if (dateTo && window.Px.moment(this.entity.dateTo).format() !== dateTo.format()) {
            this.set('entity.dateTo', dateTo.tz(this._sourceTimezone).format(this._sourceDateFormat));
          }
        }

        // Commented due to the issue in px-rangepicker, which makes impossible to set from and to moments.
        //
        // _entityDatesObserver(entity) {
        //   if (entity.dateFrom && (!this._dateFrom || window.Px.moment(this.entity.dateFrom).format() !== this._dateFrom.format())) {
        //     this.set('_dateFrom', window.Px.moment(this.entity.dateFrom));
        //   }
        //   if (entity.dateTo && (!this._dateTo || window.Px.moment(this.entity.dateTo).format() !== this._dateTo.format())) {
        //     this.set('_dateTo', window.Px.moment(this.entity.dateTo));
        //   }
        // }

        _showSlider(minBound, maxBound) {
          return minBound !== undefined && maxBound !== undefined;
        }

        _arrayHas(array, value) {
          return array.filter(v => v === value);
        }

        _resolveRegexPatterns(stringComparators, regexPatterns) {
          if (stringComparators === undefined || stringComparators.length === 0) {
            return regexPatterns;
          } else {
            return regexPatterns.filter(p => this._arrayHas(stringComparators, p.key).length > 0);
          }
        }

        _resolveNumberConditions(numberComparators, numberConditions) {
          if (numberComparators === undefined || numberComparators.length === 0) {
            return numberConditions;
          } else {
            return numberConditions.filter(c => this._arrayHas(numberComparators, c.key).length > 0);
          }
        }
      }

      customElements.define(DataGridFilterEntityElement.is, DataGridFilterEntityElement);

      /**
       * @namespace Predix
       */
      window.Predix = window.Predix || {};
      Predix.DataGridFilterEntityElement = DataGridFilterEntityElement;
    }
  </script>
</dom-module>
